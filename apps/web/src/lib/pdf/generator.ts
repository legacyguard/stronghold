import puppeteer, { Browser } from 'puppeteer';
import { WillFormData } from '../will/templates';

export interface PDFGenerationRequest {
  content: string;
  template?: 'legal_document' | 'simple' | 'official';
  metadata: {
    title: string;
    author: string;
    subject: string;
    creator: string;
  };
  options?: {
    format?: 'A4' | 'Letter';
    margins?: {
      top: string;
      bottom: string;
      left: string;
      right: string;
    };
    watermark?: string;
    header?: string;
    footer?: string;
  };
}

export interface PDFGenerationResult {
  success: boolean;
  pdfBuffer?: Buffer;
  filename: string;
  error?: string;
  metadata: {
    pages: number;
    size: number;
    generatedAt: Date;
  };
}

export class PDFGenerator {
  private static instance: PDFGenerator;
  private browser: Browser | null = null;

  static getInstance(): PDFGenerator {
    if (!PDFGenerator.instance) {
      PDFGenerator.instance = new PDFGenerator();
    }
    return PDFGenerator.instance;
  }

  async initBrowser(): Promise<void> {
    if (!this.browser) {
      try {
        this.browser = await puppeteer.launch({
          headless: true,
          args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-background-timer-throttling',
            '--disable-backgrounding-occluded-windows',
            '--disable-renderer-backgrounding'
          ]
        });
      } catch (error) {
        console.error('Failed to launch Puppeteer browser:', error);
        throw new Error('PDF generation service unavailable');
      }
    }
  }

  async generateWillPDF(willContent: string, willData: WillFormData): Promise<PDFGenerationResult> {
    const request: PDFGenerationRequest = {
      content: willContent,
      template: 'legal_document',
      metadata: {
        title: `Last Will and Testament - ${willData.fullName}`,
        author: willData.fullName || 'Unknown',
        subject: 'Legal Document - Last Will and Testament',
        creator: 'LegacyGuard Will Generator'
      },
      options: {
        format: 'A4',
        margins: {
          top: '2cm',
          bottom: '2cm',
          left: '2.5cm',
          right: '2.5cm'
        },
        header: 'LAST WILL AND TESTAMENT',
        footer: `Generated by LegacyGuard on ${new Date().toLocaleDateString()}`
      }
    };

    return this.generatePDF(request);
  }

  async generatePDF(request: PDFGenerationRequest): Promise<PDFGenerationResult> {
    const startTime = Date.now();

    try {
      await this.initBrowser();

      if (!this.browser) {
        throw new Error('Browser initialization failed');
      }

      const page = await this.browser.newPage();

      try {
        // Set page size and viewport
        await page.setViewport({ width: 210 * 4, height: 297 * 4 }); // A4 in pixels at 4x scale

        // Generate HTML content with styling
        const htmlContent = this.generateHTMLContent(request);

        // Set content and wait for fonts to load
        await page.setContent(htmlContent, {
          waitUntil: ['networkidle0', 'domcontentloaded'],
          timeout: 30000
        });

        // Generate PDF
        const pdfBuffer = Buffer.from(await page.pdf({
          format: request.options?.format || 'A4',
          margin: {
            top: request.options?.margins?.top || '2cm',
            bottom: request.options?.margins?.bottom || '2cm',
            left: request.options?.margins?.left || '2.5cm',
            right: request.options?.margins?.right || '2.5cm'
          },
          printBackground: true,
          preferCSSPageSize: false,
          displayHeaderFooter: !!(request.options?.header || request.options?.footer),
          headerTemplate: request.options?.header ? `
            <div style="font-size: 10px; width: 100%; text-align: center; color: #666; margin-top: 10px;">
              ${request.options.header}
            </div>
          ` : '<div></div>',
          footerTemplate: request.options?.footer ? `
            <div style="font-size: 10px; width: 100%; text-align: center; color: #666; margin-bottom: 10px;">
              <span>${request.options.footer}</span>
              <span style="float: right; margin-right: 1cm;">Page <span class="pageNumber"></span> of <span class="totalPages"></span></span>
            </div>
          ` : '<div></div>'
        }));

        // Generate filename
        const timestamp = new Date().toISOString().split('T')[0];
        const authorSlug = request.metadata.author.toLowerCase().replace(/[^a-z0-9]/g, '-');
        const filename = `will-${authorSlug}-${timestamp}.pdf`;

        const generationTime = Date.now() - startTime;
        console.log(`PDF generated successfully in ${generationTime}ms, size: ${pdfBuffer.length} bytes`);

        return {
          success: true,
          pdfBuffer,
          filename,
          metadata: {
            pages: await this.countPDFPages(pdfBuffer),
            size: pdfBuffer.length,
            generatedAt: new Date()
          }
        };

      } finally {
        await page.close();
      }

    } catch (error) {
      console.error('PDF generation error:', error);

      return {
        success: false,
        filename: 'error.pdf',
        error: error instanceof Error ? error.message : 'Unknown error occurred',
        metadata: {
          pages: 0,
          size: 0,
          generatedAt: new Date()
        }
      };
    }
  }

  private generateHTMLContent(request: PDFGenerationRequest): string {
    const { content, template, options } = request;

    // Base styles for legal documents
    const baseStyles = `
      body {
        font-family: 'Times New Roman', serif;
        font-size: 12pt;
        line-height: 1.6;
        color: #000;
        max-width: 100%;
        margin: 0;
        padding: 0;
        background: white;
      }

      .document-container {
        padding: 0;
        max-width: 100%;
      }

      h1, h2, h3 {
        font-weight: bold;
        margin: 1.5em 0 1em 0;
        text-align: center;
      }

      h1 {
        font-size: 18pt;
        text-transform: uppercase;
        letter-spacing: 2px;
        margin-bottom: 2em;
      }

      p {
        margin: 1em 0;
        text-align: justify;
        text-indent: 2em;
      }

      .article {
        margin: 2em 0;
      }

      .article-title {
        font-weight: bold;
        text-transform: uppercase;
        text-align: center;
        margin: 1.5em 0 1em 0;
      }

      .signature-section {
        margin-top: 4em;
        page-break-inside: avoid;
      }

      .signature-line {
        border-bottom: 1px solid #000;
        width: 200px;
        margin: 2em auto;
      }

      .watermark {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) rotate(-45deg);
        font-size: 48pt;
        color: rgba(200, 200, 200, 0.3);
        z-index: -1;
        pointer-events: none;
      }

      @page {
        size: ${options?.format || 'A4'};
        margin: 0;
      }

      @media print {
        body { -webkit-print-color-adjust: exact; }
      }
    `;

    // Template-specific styles
    let templateStyles = '';

    switch (template) {
      case 'legal_document':
        templateStyles = `
          .legal-header {
            text-align: center;
            font-weight: bold;
            font-size: 14pt;
            margin-bottom: 2em;
            text-transform: uppercase;
            letter-spacing: 1px;
          }

          .legal-article {
            margin: 2em 0;
            counter-increment: article;
          }

          .legal-article::before {
            content: "ČLÁNOK " counter(article, upper-roman) ". - ";
            font-weight: bold;
            display: block;
            text-align: center;
            margin-bottom: 1em;
          }

          body {
            counter-reset: article;
          }
        `;
        break;

      case 'official':
        templateStyles = `
          .official-seal {
            border: 3px double #000;
            padding: 20px;
            margin: 2em 0;
            text-align: center;
          }

          .date-location {
            text-align: right;
            margin: 2em 0;
            font-style: italic;
          }
        `;
        break;
    }

    // Format content for legal documents
    const formattedContent = this.formatLegalContent(content);

    return `
      <!DOCTYPE html>
      <html lang="sk">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${request.metadata.title}</title>
        <style>
          ${baseStyles}
          ${templateStyles}
        </style>
      </head>
      <body>
        ${options?.watermark ? `<div class="watermark">${options.watermark}</div>` : ''}

        <div class="document-container">
          ${formattedContent}
        </div>
      </body>
      </html>
    `;
  }

  private formatLegalContent(content: string): string {
    // Convert plain text will to properly formatted HTML
    return content
      .split('\n\n')
      .map(paragraph => {
        if (paragraph.trim().toUpperCase() === paragraph.trim() && paragraph.length < 100) {
          // Likely a heading
          return `<h1>${paragraph.trim()}</h1>`;
        } else if (paragraph.startsWith('ČLÁNOK') || paragraph.startsWith('ARTICLE')) {
          // Article heading
          return `<div class="article-title">${paragraph.trim()}</div>`;
        } else if (paragraph.trim().length > 0) {
          // Regular paragraph
          return `<p>${paragraph.trim()}</p>`;
        }
        return '';
      })
      .filter(p => p.length > 0)
      .join('\n');
  }

  private async countPDFPages(pdfBuffer: Buffer): Promise<number> {
    // Simple page count estimation based on PDF content
    // In production, you might want to use a proper PDF parser
    const pdfString = pdfBuffer.toString();
    const pageMatches = pdfString.match(/\/Type\s*\/Page[^s]/g);
    return pageMatches ? pageMatches.length : 1;
  }

  async closeBrowser(): Promise<void> {
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
  }

  // Health check method
  async healthCheck(): Promise<boolean> {
    try {
      await this.initBrowser();
      return this.browser !== null;
    } catch (error) {
      console.error('PDF service health check failed:', error);
      return false;
    }
  }
}

// Export singleton instance
export const pdfGenerator = PDFGenerator.getInstance();

// Cleanup on process exit
if (typeof process !== 'undefined') {
  process.on('exit', () => {
    pdfGenerator.closeBrowser().catch(console.error);
  });

  process.on('SIGINT', () => {
    pdfGenerator.closeBrowser().then(() => process.exit(0)).catch(console.error);
  });
}